
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `QuestionAttemptLog` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model QuestionAttemptLog
 * 
 */
export type QuestionAttemptLogModel = runtime.Types.Result.DefaultSelection<Prisma.$QuestionAttemptLogPayload>

export type AggregateQuestionAttemptLog = {
  _count: QuestionAttemptLogCountAggregateOutputType | null
  _avg: QuestionAttemptLogAvgAggregateOutputType | null
  _sum: QuestionAttemptLogSumAggregateOutputType | null
  _min: QuestionAttemptLogMinAggregateOutputType | null
  _max: QuestionAttemptLogMaxAggregateOutputType | null
}

export type QuestionAttemptLogAvgAggregateOutputType = {
  attemptCount: number | null
}

export type QuestionAttemptLogSumAggregateOutputType = {
  attemptCount: number | null
}

export type QuestionAttemptLogMinAggregateOutputType = {
  id: string | null
  attemptId: string | null
  questionId: string | null
  userAnswerText: string | null
  isCorrect: boolean | null
  attemptCount: number | null
  answeredAt: Date | null
}

export type QuestionAttemptLogMaxAggregateOutputType = {
  id: string | null
  attemptId: string | null
  questionId: string | null
  userAnswerText: string | null
  isCorrect: boolean | null
  attemptCount: number | null
  answeredAt: Date | null
}

export type QuestionAttemptLogCountAggregateOutputType = {
  id: number
  attemptId: number
  questionId: number
  userAnswerText: number
  isCorrect: number
  attemptCount: number
  answeredAt: number
  _all: number
}


export type QuestionAttemptLogAvgAggregateInputType = {
  attemptCount?: true
}

export type QuestionAttemptLogSumAggregateInputType = {
  attemptCount?: true
}

export type QuestionAttemptLogMinAggregateInputType = {
  id?: true
  attemptId?: true
  questionId?: true
  userAnswerText?: true
  isCorrect?: true
  attemptCount?: true
  answeredAt?: true
}

export type QuestionAttemptLogMaxAggregateInputType = {
  id?: true
  attemptId?: true
  questionId?: true
  userAnswerText?: true
  isCorrect?: true
  attemptCount?: true
  answeredAt?: true
}

export type QuestionAttemptLogCountAggregateInputType = {
  id?: true
  attemptId?: true
  questionId?: true
  userAnswerText?: true
  isCorrect?: true
  attemptCount?: true
  answeredAt?: true
  _all?: true
}

export type QuestionAttemptLogAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which QuestionAttemptLog to aggregate.
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QuestionAttemptLogs to fetch.
   */
  orderBy?: Prisma.QuestionAttemptLogOrderByWithRelationInput | Prisma.QuestionAttemptLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.QuestionAttemptLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QuestionAttemptLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QuestionAttemptLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned QuestionAttemptLogs
  **/
  _count?: true | QuestionAttemptLogCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: QuestionAttemptLogAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: QuestionAttemptLogSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: QuestionAttemptLogMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: QuestionAttemptLogMaxAggregateInputType
}

export type GetQuestionAttemptLogAggregateType<T extends QuestionAttemptLogAggregateArgs> = {
      [P in keyof T & keyof AggregateQuestionAttemptLog]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateQuestionAttemptLog[P]>
    : Prisma.GetScalarType<T[P], AggregateQuestionAttemptLog[P]>
}




export type QuestionAttemptLogGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.QuestionAttemptLogWhereInput
  orderBy?: Prisma.QuestionAttemptLogOrderByWithAggregationInput | Prisma.QuestionAttemptLogOrderByWithAggregationInput[]
  by: Prisma.QuestionAttemptLogScalarFieldEnum[] | Prisma.QuestionAttemptLogScalarFieldEnum
  having?: Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: QuestionAttemptLogCountAggregateInputType | true
  _avg?: QuestionAttemptLogAvgAggregateInputType
  _sum?: QuestionAttemptLogSumAggregateInputType
  _min?: QuestionAttemptLogMinAggregateInputType
  _max?: QuestionAttemptLogMaxAggregateInputType
}

export type QuestionAttemptLogGroupByOutputType = {
  id: string
  attemptId: string
  questionId: string
  userAnswerText: string | null
  isCorrect: boolean | null
  attemptCount: number
  answeredAt: Date
  _count: QuestionAttemptLogCountAggregateOutputType | null
  _avg: QuestionAttemptLogAvgAggregateOutputType | null
  _sum: QuestionAttemptLogSumAggregateOutputType | null
  _min: QuestionAttemptLogMinAggregateOutputType | null
  _max: QuestionAttemptLogMaxAggregateOutputType | null
}

type GetQuestionAttemptLogGroupByPayload<T extends QuestionAttemptLogGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<QuestionAttemptLogGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof QuestionAttemptLogGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], QuestionAttemptLogGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], QuestionAttemptLogGroupByOutputType[P]>
      }
    >
  >



export type QuestionAttemptLogWhereInput = {
  AND?: Prisma.QuestionAttemptLogWhereInput | Prisma.QuestionAttemptLogWhereInput[]
  OR?: Prisma.QuestionAttemptLogWhereInput[]
  NOT?: Prisma.QuestionAttemptLogWhereInput | Prisma.QuestionAttemptLogWhereInput[]
  id?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  attemptId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  questionId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  userAnswerText?: Prisma.StringNullableFilter<"QuestionAttemptLog"> | string | null
  isCorrect?: Prisma.BoolNullableFilter<"QuestionAttemptLog"> | boolean | null
  attemptCount?: Prisma.IntFilter<"QuestionAttemptLog"> | number
  answeredAt?: Prisma.DateTimeFilter<"QuestionAttemptLog"> | Date | string
  storyAttempt?: Prisma.XOR<Prisma.StoryAttemptScalarRelationFilter, Prisma.StoryAttemptWhereInput>
  question?: Prisma.XOR<Prisma.QuestionScalarRelationFilter, Prisma.QuestionWhereInput>
}

export type QuestionAttemptLogOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  attemptId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  userAnswerText?: Prisma.SortOrderInput | Prisma.SortOrder
  isCorrect?: Prisma.SortOrderInput | Prisma.SortOrder
  attemptCount?: Prisma.SortOrder
  answeredAt?: Prisma.SortOrder
  storyAttempt?: Prisma.StoryAttemptOrderByWithRelationInput
  question?: Prisma.QuestionOrderByWithRelationInput
}

export type QuestionAttemptLogWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.QuestionAttemptLogWhereInput | Prisma.QuestionAttemptLogWhereInput[]
  OR?: Prisma.QuestionAttemptLogWhereInput[]
  NOT?: Prisma.QuestionAttemptLogWhereInput | Prisma.QuestionAttemptLogWhereInput[]
  attemptId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  questionId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  userAnswerText?: Prisma.StringNullableFilter<"QuestionAttemptLog"> | string | null
  isCorrect?: Prisma.BoolNullableFilter<"QuestionAttemptLog"> | boolean | null
  attemptCount?: Prisma.IntFilter<"QuestionAttemptLog"> | number
  answeredAt?: Prisma.DateTimeFilter<"QuestionAttemptLog"> | Date | string
  storyAttempt?: Prisma.XOR<Prisma.StoryAttemptScalarRelationFilter, Prisma.StoryAttemptWhereInput>
  question?: Prisma.XOR<Prisma.QuestionScalarRelationFilter, Prisma.QuestionWhereInput>
}, "id">

export type QuestionAttemptLogOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  attemptId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  userAnswerText?: Prisma.SortOrderInput | Prisma.SortOrder
  isCorrect?: Prisma.SortOrderInput | Prisma.SortOrder
  attemptCount?: Prisma.SortOrder
  answeredAt?: Prisma.SortOrder
  _count?: Prisma.QuestionAttemptLogCountOrderByAggregateInput
  _avg?: Prisma.QuestionAttemptLogAvgOrderByAggregateInput
  _max?: Prisma.QuestionAttemptLogMaxOrderByAggregateInput
  _min?: Prisma.QuestionAttemptLogMinOrderByAggregateInput
  _sum?: Prisma.QuestionAttemptLogSumOrderByAggregateInput
}

export type QuestionAttemptLogScalarWhereWithAggregatesInput = {
  AND?: Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput | Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput[]
  OR?: Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput[]
  NOT?: Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput | Prisma.QuestionAttemptLogScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"QuestionAttemptLog"> | string
  attemptId?: Prisma.StringWithAggregatesFilter<"QuestionAttemptLog"> | string
  questionId?: Prisma.StringWithAggregatesFilter<"QuestionAttemptLog"> | string
  userAnswerText?: Prisma.StringNullableWithAggregatesFilter<"QuestionAttemptLog"> | string | null
  isCorrect?: Prisma.BoolNullableWithAggregatesFilter<"QuestionAttemptLog"> | boolean | null
  attemptCount?: Prisma.IntWithAggregatesFilter<"QuestionAttemptLog"> | number
  answeredAt?: Prisma.DateTimeWithAggregatesFilter<"QuestionAttemptLog"> | Date | string
}

export type QuestionAttemptLogCreateInput = {
  id?: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
  storyAttempt: Prisma.StoryAttemptCreateNestedOneWithoutQuestionLogsInput
  question: Prisma.QuestionCreateNestedOneWithoutAttemptLogsInput
}

export type QuestionAttemptLogUncheckedCreateInput = {
  id?: string
  attemptId: string
  questionId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  storyAttempt?: Prisma.StoryAttemptUpdateOneRequiredWithoutQuestionLogsNestedInput
  question?: Prisma.QuestionUpdateOneRequiredWithoutAttemptLogsNestedInput
}

export type QuestionAttemptLogUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  attemptId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogCreateManyInput = {
  id?: string
  attemptId: string
  questionId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  attemptId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogListRelationFilter = {
  every?: Prisma.QuestionAttemptLogWhereInput
  some?: Prisma.QuestionAttemptLogWhereInput
  none?: Prisma.QuestionAttemptLogWhereInput
}

export type QuestionAttemptLogOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type QuestionAttemptLogCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  attemptId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  userAnswerText?: Prisma.SortOrder
  isCorrect?: Prisma.SortOrder
  attemptCount?: Prisma.SortOrder
  answeredAt?: Prisma.SortOrder
}

export type QuestionAttemptLogAvgOrderByAggregateInput = {
  attemptCount?: Prisma.SortOrder
}

export type QuestionAttemptLogMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  attemptId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  userAnswerText?: Prisma.SortOrder
  isCorrect?: Prisma.SortOrder
  attemptCount?: Prisma.SortOrder
  answeredAt?: Prisma.SortOrder
}

export type QuestionAttemptLogMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  attemptId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  userAnswerText?: Prisma.SortOrder
  isCorrect?: Prisma.SortOrder
  attemptCount?: Prisma.SortOrder
  answeredAt?: Prisma.SortOrder
}

export type QuestionAttemptLogSumOrderByAggregateInput = {
  attemptCount?: Prisma.SortOrder
}

export type QuestionAttemptLogCreateNestedManyWithoutStoryAttemptInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput> | Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyStoryAttemptInputEnvelope
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
}

export type QuestionAttemptLogUncheckedCreateNestedManyWithoutStoryAttemptInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput> | Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyStoryAttemptInputEnvelope
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
}

export type QuestionAttemptLogUpdateManyWithoutStoryAttemptNestedInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput> | Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput[]
  upsert?: Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutStoryAttemptInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyStoryAttemptInputEnvelope
  set?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  disconnect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  delete?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  update?: Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutStoryAttemptInput[]
  updateMany?: Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutStoryAttemptInput[]
  deleteMany?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
}

export type QuestionAttemptLogUncheckedUpdateManyWithoutStoryAttemptNestedInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput> | Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput[]
  upsert?: Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutStoryAttemptInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyStoryAttemptInputEnvelope
  set?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  disconnect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  delete?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  update?: Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutStoryAttemptInput[]
  updateMany?: Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutStoryAttemptInput | Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutStoryAttemptInput[]
  deleteMany?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type QuestionAttemptLogCreateNestedManyWithoutQuestionInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput> | Prisma.QuestionAttemptLogCreateWithoutQuestionInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyQuestionInputEnvelope
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
}

export type QuestionAttemptLogUncheckedCreateNestedManyWithoutQuestionInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput> | Prisma.QuestionAttemptLogCreateWithoutQuestionInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyQuestionInputEnvelope
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
}

export type QuestionAttemptLogUpdateManyWithoutQuestionNestedInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput> | Prisma.QuestionAttemptLogCreateWithoutQuestionInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput[]
  upsert?: Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutQuestionInput | Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutQuestionInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyQuestionInputEnvelope
  set?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  disconnect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  delete?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  update?: Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutQuestionInput | Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutQuestionInput[]
  updateMany?: Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutQuestionInput | Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutQuestionInput[]
  deleteMany?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
}

export type QuestionAttemptLogUncheckedUpdateManyWithoutQuestionNestedInput = {
  create?: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput> | Prisma.QuestionAttemptLogCreateWithoutQuestionInput[] | Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput | Prisma.QuestionAttemptLogCreateOrConnectWithoutQuestionInput[]
  upsert?: Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutQuestionInput | Prisma.QuestionAttemptLogUpsertWithWhereUniqueWithoutQuestionInput[]
  createMany?: Prisma.QuestionAttemptLogCreateManyQuestionInputEnvelope
  set?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  disconnect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  delete?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  connect?: Prisma.QuestionAttemptLogWhereUniqueInput | Prisma.QuestionAttemptLogWhereUniqueInput[]
  update?: Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutQuestionInput | Prisma.QuestionAttemptLogUpdateWithWhereUniqueWithoutQuestionInput[]
  updateMany?: Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutQuestionInput | Prisma.QuestionAttemptLogUpdateManyWithWhereWithoutQuestionInput[]
  deleteMany?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
}

export type QuestionAttemptLogCreateWithoutStoryAttemptInput = {
  id?: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
  question: Prisma.QuestionCreateNestedOneWithoutAttemptLogsInput
}

export type QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput = {
  id?: string
  questionId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogCreateOrConnectWithoutStoryAttemptInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  create: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput>
}

export type QuestionAttemptLogCreateManyStoryAttemptInputEnvelope = {
  data: Prisma.QuestionAttemptLogCreateManyStoryAttemptInput | Prisma.QuestionAttemptLogCreateManyStoryAttemptInput[]
  skipDuplicates?: boolean
}

export type QuestionAttemptLogUpsertWithWhereUniqueWithoutStoryAttemptInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  update: Prisma.XOR<Prisma.QuestionAttemptLogUpdateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedUpdateWithoutStoryAttemptInput>
  create: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutStoryAttemptInput>
}

export type QuestionAttemptLogUpdateWithWhereUniqueWithoutStoryAttemptInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateWithoutStoryAttemptInput, Prisma.QuestionAttemptLogUncheckedUpdateWithoutStoryAttemptInput>
}

export type QuestionAttemptLogUpdateManyWithWhereWithoutStoryAttemptInput = {
  where: Prisma.QuestionAttemptLogScalarWhereInput
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateManyMutationInput, Prisma.QuestionAttemptLogUncheckedUpdateManyWithoutStoryAttemptInput>
}

export type QuestionAttemptLogScalarWhereInput = {
  AND?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
  OR?: Prisma.QuestionAttemptLogScalarWhereInput[]
  NOT?: Prisma.QuestionAttemptLogScalarWhereInput | Prisma.QuestionAttemptLogScalarWhereInput[]
  id?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  attemptId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  questionId?: Prisma.StringFilter<"QuestionAttemptLog"> | string
  userAnswerText?: Prisma.StringNullableFilter<"QuestionAttemptLog"> | string | null
  isCorrect?: Prisma.BoolNullableFilter<"QuestionAttemptLog"> | boolean | null
  attemptCount?: Prisma.IntFilter<"QuestionAttemptLog"> | number
  answeredAt?: Prisma.DateTimeFilter<"QuestionAttemptLog"> | Date | string
}

export type QuestionAttemptLogCreateWithoutQuestionInput = {
  id?: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
  storyAttempt: Prisma.StoryAttemptCreateNestedOneWithoutQuestionLogsInput
}

export type QuestionAttemptLogUncheckedCreateWithoutQuestionInput = {
  id?: string
  attemptId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogCreateOrConnectWithoutQuestionInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  create: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput>
}

export type QuestionAttemptLogCreateManyQuestionInputEnvelope = {
  data: Prisma.QuestionAttemptLogCreateManyQuestionInput | Prisma.QuestionAttemptLogCreateManyQuestionInput[]
  skipDuplicates?: boolean
}

export type QuestionAttemptLogUpsertWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  update: Prisma.XOR<Prisma.QuestionAttemptLogUpdateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedUpdateWithoutQuestionInput>
  create: Prisma.XOR<Prisma.QuestionAttemptLogCreateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedCreateWithoutQuestionInput>
}

export type QuestionAttemptLogUpdateWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateWithoutQuestionInput, Prisma.QuestionAttemptLogUncheckedUpdateWithoutQuestionInput>
}

export type QuestionAttemptLogUpdateManyWithWhereWithoutQuestionInput = {
  where: Prisma.QuestionAttemptLogScalarWhereInput
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateManyMutationInput, Prisma.QuestionAttemptLogUncheckedUpdateManyWithoutQuestionInput>
}

export type QuestionAttemptLogCreateManyStoryAttemptInput = {
  id?: string
  questionId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogUpdateWithoutStoryAttemptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  question?: Prisma.QuestionUpdateOneRequiredWithoutAttemptLogsNestedInput
}

export type QuestionAttemptLogUncheckedUpdateWithoutStoryAttemptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogUncheckedUpdateManyWithoutStoryAttemptInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogCreateManyQuestionInput = {
  id?: string
  attemptId: string
  userAnswerText?: string | null
  isCorrect?: boolean | null
  attemptCount?: number
  answeredAt?: Date | string
}

export type QuestionAttemptLogUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  storyAttempt?: Prisma.StoryAttemptUpdateOneRequiredWithoutQuestionLogsNestedInput
}

export type QuestionAttemptLogUncheckedUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  attemptId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type QuestionAttemptLogUncheckedUpdateManyWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  attemptId?: Prisma.StringFieldUpdateOperationsInput | string
  userAnswerText?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isCorrect?: Prisma.NullableBoolFieldUpdateOperationsInput | boolean | null
  attemptCount?: Prisma.IntFieldUpdateOperationsInput | number
  answeredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type QuestionAttemptLogSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  attemptId?: boolean
  questionId?: boolean
  userAnswerText?: boolean
  isCorrect?: boolean
  attemptCount?: boolean
  answeredAt?: boolean
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}, ExtArgs["result"]["questionAttemptLog"]>

export type QuestionAttemptLogSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  attemptId?: boolean
  questionId?: boolean
  userAnswerText?: boolean
  isCorrect?: boolean
  attemptCount?: boolean
  answeredAt?: boolean
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}, ExtArgs["result"]["questionAttemptLog"]>

export type QuestionAttemptLogSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  attemptId?: boolean
  questionId?: boolean
  userAnswerText?: boolean
  isCorrect?: boolean
  attemptCount?: boolean
  answeredAt?: boolean
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}, ExtArgs["result"]["questionAttemptLog"]>

export type QuestionAttemptLogSelectScalar = {
  id?: boolean
  attemptId?: boolean
  questionId?: boolean
  userAnswerText?: boolean
  isCorrect?: boolean
  attemptCount?: boolean
  answeredAt?: boolean
}

export type QuestionAttemptLogOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "attemptId" | "questionId" | "userAnswerText" | "isCorrect" | "attemptCount" | "answeredAt", ExtArgs["result"]["questionAttemptLog"]>
export type QuestionAttemptLogInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}
export type QuestionAttemptLogIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}
export type QuestionAttemptLogIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  storyAttempt?: boolean | Prisma.StoryAttemptDefaultArgs<ExtArgs>
  question?: boolean | Prisma.QuestionDefaultArgs<ExtArgs>
}

export type $QuestionAttemptLogPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "QuestionAttemptLog"
  objects: {
    storyAttempt: Prisma.$StoryAttemptPayload<ExtArgs>
    question: Prisma.$QuestionPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    attemptId: string
    questionId: string
    userAnswerText: string | null
    isCorrect: boolean | null
    attemptCount: number
    answeredAt: Date
  }, ExtArgs["result"]["questionAttemptLog"]>
  composites: {}
}

export type QuestionAttemptLogGetPayload<S extends boolean | null | undefined | QuestionAttemptLogDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload, S>

export type QuestionAttemptLogCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<QuestionAttemptLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: QuestionAttemptLogCountAggregateInputType | true
  }

export interface QuestionAttemptLogDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAttemptLog'], meta: { name: 'QuestionAttemptLog' } }
  /**
   * Find zero or one QuestionAttemptLog that matches the filter.
   * @param {QuestionAttemptLogFindUniqueArgs} args - Arguments to find a QuestionAttemptLog
   * @example
   * // Get one QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends QuestionAttemptLogFindUniqueArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogFindUniqueArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one QuestionAttemptLog that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {QuestionAttemptLogFindUniqueOrThrowArgs} args - Arguments to find a QuestionAttemptLog
   * @example
   * // Get one QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends QuestionAttemptLogFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first QuestionAttemptLog that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogFindFirstArgs} args - Arguments to find a QuestionAttemptLog
   * @example
   * // Get one QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends QuestionAttemptLogFindFirstArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogFindFirstArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first QuestionAttemptLog that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogFindFirstOrThrowArgs} args - Arguments to find a QuestionAttemptLog
   * @example
   * // Get one QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends QuestionAttemptLogFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more QuestionAttemptLogs that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all QuestionAttemptLogs
   * const questionAttemptLogs = await prisma.questionAttemptLog.findMany()
   * 
   * // Get first 10 QuestionAttemptLogs
   * const questionAttemptLogs = await prisma.questionAttemptLog.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const questionAttemptLogWithIdOnly = await prisma.questionAttemptLog.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends QuestionAttemptLogFindManyArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a QuestionAttemptLog.
   * @param {QuestionAttemptLogCreateArgs} args - Arguments to create a QuestionAttemptLog.
   * @example
   * // Create one QuestionAttemptLog
   * const QuestionAttemptLog = await prisma.questionAttemptLog.create({
   *   data: {
   *     // ... data to create a QuestionAttemptLog
   *   }
   * })
   * 
   */
  create<T extends QuestionAttemptLogCreateArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogCreateArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many QuestionAttemptLogs.
   * @param {QuestionAttemptLogCreateManyArgs} args - Arguments to create many QuestionAttemptLogs.
   * @example
   * // Create many QuestionAttemptLogs
   * const questionAttemptLog = await prisma.questionAttemptLog.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends QuestionAttemptLogCreateManyArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many QuestionAttemptLogs and returns the data saved in the database.
   * @param {QuestionAttemptLogCreateManyAndReturnArgs} args - Arguments to create many QuestionAttemptLogs.
   * @example
   * // Create many QuestionAttemptLogs
   * const questionAttemptLog = await prisma.questionAttemptLog.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many QuestionAttemptLogs and only return the `id`
   * const questionAttemptLogWithIdOnly = await prisma.questionAttemptLog.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends QuestionAttemptLogCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a QuestionAttemptLog.
   * @param {QuestionAttemptLogDeleteArgs} args - Arguments to delete one QuestionAttemptLog.
   * @example
   * // Delete one QuestionAttemptLog
   * const QuestionAttemptLog = await prisma.questionAttemptLog.delete({
   *   where: {
   *     // ... filter to delete one QuestionAttemptLog
   *   }
   * })
   * 
   */
  delete<T extends QuestionAttemptLogDeleteArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogDeleteArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one QuestionAttemptLog.
   * @param {QuestionAttemptLogUpdateArgs} args - Arguments to update one QuestionAttemptLog.
   * @example
   * // Update one QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends QuestionAttemptLogUpdateArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogUpdateArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more QuestionAttemptLogs.
   * @param {QuestionAttemptLogDeleteManyArgs} args - Arguments to filter QuestionAttemptLogs to delete.
   * @example
   * // Delete a few QuestionAttemptLogs
   * const { count } = await prisma.questionAttemptLog.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends QuestionAttemptLogDeleteManyArgs>(args?: Prisma.SelectSubset<T, QuestionAttemptLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more QuestionAttemptLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many QuestionAttemptLogs
   * const questionAttemptLog = await prisma.questionAttemptLog.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends QuestionAttemptLogUpdateManyArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more QuestionAttemptLogs and returns the data updated in the database.
   * @param {QuestionAttemptLogUpdateManyAndReturnArgs} args - Arguments to update many QuestionAttemptLogs.
   * @example
   * // Update many QuestionAttemptLogs
   * const questionAttemptLog = await prisma.questionAttemptLog.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more QuestionAttemptLogs and only return the `id`
   * const questionAttemptLogWithIdOnly = await prisma.questionAttemptLog.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends QuestionAttemptLogUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one QuestionAttemptLog.
   * @param {QuestionAttemptLogUpsertArgs} args - Arguments to update or create a QuestionAttemptLog.
   * @example
   * // Update or create a QuestionAttemptLog
   * const questionAttemptLog = await prisma.questionAttemptLog.upsert({
   *   create: {
   *     // ... data to create a QuestionAttemptLog
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the QuestionAttemptLog we want to update
   *   }
   * })
   */
  upsert<T extends QuestionAttemptLogUpsertArgs>(args: Prisma.SelectSubset<T, QuestionAttemptLogUpsertArgs<ExtArgs>>): Prisma.Prisma__QuestionAttemptLogClient<runtime.Types.Result.GetResult<Prisma.$QuestionAttemptLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of QuestionAttemptLogs.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogCountArgs} args - Arguments to filter QuestionAttemptLogs to count.
   * @example
   * // Count the number of QuestionAttemptLogs
   * const count = await prisma.questionAttemptLog.count({
   *   where: {
   *     // ... the filter for the QuestionAttemptLogs we want to count
   *   }
   * })
  **/
  count<T extends QuestionAttemptLogCountArgs>(
    args?: Prisma.Subset<T, QuestionAttemptLogCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], QuestionAttemptLogCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a QuestionAttemptLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends QuestionAttemptLogAggregateArgs>(args: Prisma.Subset<T, QuestionAttemptLogAggregateArgs>): Prisma.PrismaPromise<GetQuestionAttemptLogAggregateType<T>>

  /**
   * Group by QuestionAttemptLog.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {QuestionAttemptLogGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends QuestionAttemptLogGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: QuestionAttemptLogGroupByArgs['orderBy'] }
      : { orderBy?: QuestionAttemptLogGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, QuestionAttemptLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAttemptLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the QuestionAttemptLog model
 */
readonly fields: QuestionAttemptLogFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for QuestionAttemptLog.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__QuestionAttemptLogClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  storyAttempt<T extends Prisma.StoryAttemptDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.StoryAttemptDefaultArgs<ExtArgs>>): Prisma.Prisma__StoryAttemptClient<runtime.Types.Result.GetResult<Prisma.$StoryAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  question<T extends Prisma.QuestionDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.QuestionDefaultArgs<ExtArgs>>): Prisma.Prisma__QuestionClient<runtime.Types.Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the QuestionAttemptLog model
 */
export interface QuestionAttemptLogFieldRefs {
  readonly id: Prisma.FieldRef<"QuestionAttemptLog", 'String'>
  readonly attemptId: Prisma.FieldRef<"QuestionAttemptLog", 'String'>
  readonly questionId: Prisma.FieldRef<"QuestionAttemptLog", 'String'>
  readonly userAnswerText: Prisma.FieldRef<"QuestionAttemptLog", 'String'>
  readonly isCorrect: Prisma.FieldRef<"QuestionAttemptLog", 'Boolean'>
  readonly attemptCount: Prisma.FieldRef<"QuestionAttemptLog", 'Int'>
  readonly answeredAt: Prisma.FieldRef<"QuestionAttemptLog", 'DateTime'>
}
    

// Custom InputTypes
/**
 * QuestionAttemptLog findUnique
 */
export type QuestionAttemptLogFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter, which QuestionAttemptLog to fetch.
   */
  where: Prisma.QuestionAttemptLogWhereUniqueInput
}

/**
 * QuestionAttemptLog findUniqueOrThrow
 */
export type QuestionAttemptLogFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter, which QuestionAttemptLog to fetch.
   */
  where: Prisma.QuestionAttemptLogWhereUniqueInput
}

/**
 * QuestionAttemptLog findFirst
 */
export type QuestionAttemptLogFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter, which QuestionAttemptLog to fetch.
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QuestionAttemptLogs to fetch.
   */
  orderBy?: Prisma.QuestionAttemptLogOrderByWithRelationInput | Prisma.QuestionAttemptLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for QuestionAttemptLogs.
   */
  cursor?: Prisma.QuestionAttemptLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QuestionAttemptLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QuestionAttemptLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of QuestionAttemptLogs.
   */
  distinct?: Prisma.QuestionAttemptLogScalarFieldEnum | Prisma.QuestionAttemptLogScalarFieldEnum[]
}

/**
 * QuestionAttemptLog findFirstOrThrow
 */
export type QuestionAttemptLogFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter, which QuestionAttemptLog to fetch.
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QuestionAttemptLogs to fetch.
   */
  orderBy?: Prisma.QuestionAttemptLogOrderByWithRelationInput | Prisma.QuestionAttemptLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for QuestionAttemptLogs.
   */
  cursor?: Prisma.QuestionAttemptLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QuestionAttemptLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QuestionAttemptLogs.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of QuestionAttemptLogs.
   */
  distinct?: Prisma.QuestionAttemptLogScalarFieldEnum | Prisma.QuestionAttemptLogScalarFieldEnum[]
}

/**
 * QuestionAttemptLog findMany
 */
export type QuestionAttemptLogFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter, which QuestionAttemptLogs to fetch.
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of QuestionAttemptLogs to fetch.
   */
  orderBy?: Prisma.QuestionAttemptLogOrderByWithRelationInput | Prisma.QuestionAttemptLogOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing QuestionAttemptLogs.
   */
  cursor?: Prisma.QuestionAttemptLogWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` QuestionAttemptLogs from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` QuestionAttemptLogs.
   */
  skip?: number
  distinct?: Prisma.QuestionAttemptLogScalarFieldEnum | Prisma.QuestionAttemptLogScalarFieldEnum[]
}

/**
 * QuestionAttemptLog create
 */
export type QuestionAttemptLogCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * The data needed to create a QuestionAttemptLog.
   */
  data: Prisma.XOR<Prisma.QuestionAttemptLogCreateInput, Prisma.QuestionAttemptLogUncheckedCreateInput>
}

/**
 * QuestionAttemptLog createMany
 */
export type QuestionAttemptLogCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many QuestionAttemptLogs.
   */
  data: Prisma.QuestionAttemptLogCreateManyInput | Prisma.QuestionAttemptLogCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * QuestionAttemptLog createManyAndReturn
 */
export type QuestionAttemptLogCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * The data used to create many QuestionAttemptLogs.
   */
  data: Prisma.QuestionAttemptLogCreateManyInput | Prisma.QuestionAttemptLogCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * QuestionAttemptLog update
 */
export type QuestionAttemptLogUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * The data needed to update a QuestionAttemptLog.
   */
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateInput, Prisma.QuestionAttemptLogUncheckedUpdateInput>
  /**
   * Choose, which QuestionAttemptLog to update.
   */
  where: Prisma.QuestionAttemptLogWhereUniqueInput
}

/**
 * QuestionAttemptLog updateMany
 */
export type QuestionAttemptLogUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update QuestionAttemptLogs.
   */
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateManyMutationInput, Prisma.QuestionAttemptLogUncheckedUpdateManyInput>
  /**
   * Filter which QuestionAttemptLogs to update
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * Limit how many QuestionAttemptLogs to update.
   */
  limit?: number
}

/**
 * QuestionAttemptLog updateManyAndReturn
 */
export type QuestionAttemptLogUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * The data used to update QuestionAttemptLogs.
   */
  data: Prisma.XOR<Prisma.QuestionAttemptLogUpdateManyMutationInput, Prisma.QuestionAttemptLogUncheckedUpdateManyInput>
  /**
   * Filter which QuestionAttemptLogs to update
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * Limit how many QuestionAttemptLogs to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * QuestionAttemptLog upsert
 */
export type QuestionAttemptLogUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * The filter to search for the QuestionAttemptLog to update in case it exists.
   */
  where: Prisma.QuestionAttemptLogWhereUniqueInput
  /**
   * In case the QuestionAttemptLog found by the `where` argument doesn't exist, create a new QuestionAttemptLog with this data.
   */
  create: Prisma.XOR<Prisma.QuestionAttemptLogCreateInput, Prisma.QuestionAttemptLogUncheckedCreateInput>
  /**
   * In case the QuestionAttemptLog was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.QuestionAttemptLogUpdateInput, Prisma.QuestionAttemptLogUncheckedUpdateInput>
}

/**
 * QuestionAttemptLog delete
 */
export type QuestionAttemptLogDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
  /**
   * Filter which QuestionAttemptLog to delete.
   */
  where: Prisma.QuestionAttemptLogWhereUniqueInput
}

/**
 * QuestionAttemptLog deleteMany
 */
export type QuestionAttemptLogDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which QuestionAttemptLogs to delete
   */
  where?: Prisma.QuestionAttemptLogWhereInput
  /**
   * Limit how many QuestionAttemptLogs to delete.
   */
  limit?: number
}

/**
 * QuestionAttemptLog without action
 */
export type QuestionAttemptLogDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the QuestionAttemptLog
   */
  select?: Prisma.QuestionAttemptLogSelect<ExtArgs> | null
  /**
   * Omit specific fields from the QuestionAttemptLog
   */
  omit?: Prisma.QuestionAttemptLogOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.QuestionAttemptLogInclude<ExtArgs> | null
}
